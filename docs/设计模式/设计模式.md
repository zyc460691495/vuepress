

# 二、设计模式

> 软件开发中不变的真理     CHANGE

## 1、策略模式

```java
public abstract class Duck {

    public void quack(){
        System.out.println("呱呱叫");
    }
    
    abstract public void display();
}


public class MallardDuck extends Duck{

    @Override
    public void display() {
        System.out.println("绿头鸭子");
    }
}

public class RedheadDuck extends Duck{
    
    @Override
    public void display() {
        System.out.println("红头鸭子");
    }
}

public class RubberDuck extends Duck{

    @Override
    public void quack(){
        System.out.println("吱吱吱");
    }
    
    @Override
    public void display() {
        System.out.println("橡皮鸭子");
    }
}
```

### 改变

给鸭子增加一个飞的方法

- 继承

```java
//给鸭子增加一个fly方法，在父类中添加一个新方法，这样鸭子就能获取“飞”的行为
public abstract class Duck {

    ……
    public void fly(){
        System.out.println("飞");
    }
}

//使用继承来提供fly行为，改变会牵一发而动全身，造成其他不想要的改变
//橡皮鸭子没有飞的能力，为了复用而使用继承会带来一些问题
Duck rubberDuck = new RubberDuck();
rubberDuck.fly();

//可以通过重写来暂时解决这一问题，当不需要的改变很多时，可能要造成大量的“什么都不做”重写
public class RubberDuck extends Duck{
    ……
    @Override
    public void fly() {
        //什么都不做
    }
}
```

- 接口

```java
//使用接口，把一些特殊的行为（fly）提取出来放到接口中，有需要的鸭子自己去实现
public interface IFly {

    void fly();
}

public class MallardDuck extends Duck implements IFly {
    ……
    @Override
    public void fly() {
        System.out.println("绿头鸭子飞");
    }
}

public class RedheadDuck extends Duck implements IFly {
    ……
    @Override
    public void fly() {
        System.out.println("红头鸭子飞");
    }
}

//接口解决了继承带来的牵一发而动全身的问题，但带来无法复用的问题，每当需要飞的行为不得不实现接口，造成冗余
```

- 设计原则

```java
//开闭原则，对扩展开放，对修改关闭，找出应用中可能需要的变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。把会变化的部分取出封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。
//依赖倒置，针对接口编程而不是针对实现编程，RedheadDuck和MallardDuck是直接实现IFly接口，被实现所绑定

//在IFly的基础上加一层行为层，这层实现具体的fly行为，不再由XXXDuck直接实现fly行为，这样Duck就可以通过IFly指定规则，不去关心具体实现，面向接口编程
public class FlyWithWings implements IFly{
    @Override
    public void fly() {
        System.out.println("用翅膀飞");
    }
}

public class FlyNoWay implements IFly{
    @Override
    public void fly() {
         //不能飞
        System.out.println("不能飞");
    }
}

//多用组合少用继承
//利用运行时多态，用IFly表示fly行为，在运行时引用正确的行为
public abstract class Duck {

    IFly iFly;
    ……
    public void fly(){
        iFly.fly();
    }
}

public class RedheadDuck extends Duck {

    public RedheadDuck(){
        iFly = new FlyWithWings();
    }
    ……
}

public class MallardDuck extends Duck {

    public MallardDuck() {
        iFly = new FlyWithWings();
    }
    ……
}

public class RubberDuck extends Duck {

    public RubberDuck() {
        iFly = new FlyNoWay();
    }
    ……
}
//定义了了算法族（IFly），封装了具体fly行为，让FlyWithWings和FlyNoWay可以相互替换，使用FlyWithWings和FlyNoWay的部分不用关心算法的变化
```

### 定义

策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

## 2、观察者模式

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新

```java
//设计原则----针对接口编程
//主题
public interface Subject {

    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}
//观察者
public interface Observer {

    void update(float temp,float humidity,float pressure);
}
//展示面板
public interface DisplayElement {

    void display();
}

//
public class WeatherData implements Subject {

    //设计原则----多用组合，少用继承
    private ArrayList<Observer> observers;
    private float temp;
    private float humidity;
    private float pressure;

    public WeatherData() {
        observers = new ArrayList<Observer>();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(temp, humidity, pressure);
        }
    }

    public void measurementsChanged() {
        notifyObservers();
    }

    public void setMeasurements(float temp, float humidity, float pressure) {
        this.temp = temp;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }
}


public class CurrentConditionsDisplay implements Observer,DisplayElement{

    private float temp;
    private float humidity;
//    private Subject weatherData;

    public CurrentConditionsDisplay(WeatherData weatherData){
//        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }

    @Override
    public void display() {
        System.out.println("CurrentConditionsDisplay:"+"temp="+ temp+"  humidity"+humidity);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        this.temp=temp;
        this.humidity=humidity;
        display();
    }
}

//主题注册观察者，有信息更新时推送给观察者
public class Demo {
    public static void main(String[] args) {

        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        weatherData.setMeasurements(50,20,45);
    }
}
//为了交互对象之间的松耦合设计而努力
//设计原则----对扩展开放，对修改关闭，当需要添加新的展示面板不用修改主题，只需注册并自定义展示效果
```

### Java内置的观察者模式

```java
//subject
//与自定义的主题不同的是多了changed属性，changed必须为true，才能通知观察者更新状态，用于过滤一些细微的改变，当这些改变微小时不需要通知观察者做出更新
//
//protected synchronized void setChanged() {
      // if (改变超过一定范围)
     //    changed = true;
//}
public class WeatherData extends Observable {

    private float temp;
    private float humidity;
    private float pressure;

    public float getTemp() {
        return temp;
    }

    public float getHumidity() {
        return humidity;
    }

    public float getPressure() {
        return pressure;
    }

    public void measurementsChanged() {
        setChanged();
        notifyObservers();
    }

    public void setMeasurements(float temp, float humidity, float pressure) {
        this.temp = temp;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }
}

//observer
//和自己实现的接口不同，观察者获取数据是通过“拉的方式”，自己想要什么数据从subject中get,而不是subject直接推
package weather._01;

import java.util.Observable;
import java.util.Observer;

public class CurrentConditionsDisplay implements Observer, DisplayElement{

    private float temp;
    private float humidity;

    public CurrentConditionsDisplay(WeatherData weatherData){
        weatherData.addObserver(this);
    }

    @Override
    public void display() {
        System.out.println("CurrentConditionsDisplay:"+"temp="+ temp+"  humidity"+humidity);
    }

    @Override
    public void update(Observable o, Object arg) {
        WeatherData weatherData = (WeatherData) o;
        this.temp = weatherData.getTemp();
        this.humidity = weatherData.getHumidity();
        display();
    }
}

//java.util.Observable的缺点
//是一个类，java不支持多继承，限制了使用场景
//更新操作中含有protect访问限制，只能继承使用，不能组合
```

## 3、装饰器模式

```java
//饮料基类
public class Beverage {

    private String description;
    private boolean milk;
    private boolean soy;
    private boolean mocha;
    private boolean whip;

    //setter和getter
    //计算配料价格
    public double cost(){

        double cost= 0;
        if (isMilk()){
            cost +=Constant.MILK_COST;
        }
        if (isSoy()){
            cost +=Constant.SOY_COST;
        }if (isMocha()){
            cost +=Constant.MOCHA_COST;
        }if (isWhip()){
            cost +=Constant.WHIP_COST;
        }
        return cost;
    }

    public String getAddString() {
        String add=" add";
        if (isMilk()){
            add +=" milk";
        }if (isMocha()){
            add +=" mocha";
        }if (isSoy()){
            add +=" soy";
        }if (isWhip()){
            add +=" whip";
        }
        return add;
    }
}

//
public class DarkRoast extends Beverage{

    public DarkRoast(){
        setDescription("Dark Roast");
    }

    @Override
    public double cost() {
        return super.cost()+Constant.DARK_ROAST_COST;
    }

    @Override
    public String toString() {
        return getDescription() +getAddString()+" is $"+ cost();
    }
}

DarkRoast darkRoast = new DarkRoast();
darkRoast.setMilk(true);
darkRoast.setMocha(true);
System.out.println(darkRoast);
//==> Dark Roast add milk mocha is $6.5
```

### 改变

出现新的配料，就需要修改大量的代码，对于冰红茶不需要豆浆等配料，要加双倍的奶泡也无法实现

```java
//以饮料为主体，将各种配料当成装饰品

//无论是具体饮料还是配料都是Beverage的子类
public abstract class Beverage {
    private String description;

    public void setDescription(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    public abstract double cost();
}

//具体饮料
public class HouseBlend extends Beverage{

    public HouseBlend(){
        setDescription("House Blend");
    }

    @Override
    public double cost() {
        return Constant.HOUSE_BLEND_COST;
    }
}

//装饰器和主体拥有相同的类型，
public abstract class CondimentDecorator extends Beverage{

    public abstract String getDescription();
}

//装饰者
public class Mocha extends CondimentDecorator{

    //是主体也是被装饰者
    private Beverage beverage;

    public Mocha(Beverage beverage){
        this.beverage=beverage;
    }

    @Override
    public double cost() {
        return beverage.cost()+ Constant.MOCHA_COST;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription()+" + Mocha";
    }
}

Beverage houseBlend = new HouseBlend();
houseBlend = new Mocha(houseBlend);
houseBlend = new Mocha(houseBlend);
System.out.println(houseBlend.getDescription());
System.out.println(houseBlend.cost());
// ==> House Blend + Mocha + Mocha  5.0

//装饰者和被装饰者有相同的超类型，使得装饰者可以替代被装饰者（被装饰者以实例变量的形式组合到装饰者中），并添加装饰者自己的行为。
```

![image-20220823105804551](D:\笔记\设计模式.assets\image-20220823105804551.png)

### 定义

装饰者模式动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

![image-20220823103459491](D:\笔记\设计模式.assets\image-20220823103459491.png)

## 4、工厂模式

```java
public interface Pizza {
    void prepare();
    void bake();
    void cut();
    void box();
}

public Pizza orderPizza(String type){
    //容易变化的部分
    Pizza pizza = null;
    if (type.equals("cheese")){
       pizza = new CheesePizza();
    }else if (type.equals("greek")){
        pizza = new GreekPizza();
    }
    //不会轻易改变的部分
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
}
```

### 改变

添加新的的比萨种类，删除一些旧的种类

- 直接修改

```java
//这部分会不断修改代码
public Pizza orderPizza(String type){
    //容易变化的部分
    Pizza pizza = null;
    if (type.equals("cheese")){
       pizza = new CheesePizza();
    }else if (type.equals("clam")){
        pizza = new ClamPizza();
    }
    ……
}
```

- 设计原则


```java
//封装变化
//工厂处理创建对象的细节，SimplePizzaFactory对象就叫做工厂
public class SimplePizzaFactory {
    public Pizza createPizza(String type){
        Pizza pizza = null;
        if (type.equals("cheese")){
            pizza = new CheesePizza();
        }else if (type.equals("greek")){
            pizza = new GreekPizza();
        }
        return pizza;
    }
}

public class PizzaStore {
    private SimplePizzaFactory factory;
    public PizzaStore(SimplePizzaFactory factory){
        this.factory=factory;
    }

    public Pizza orderPizza(String type){
        Pizza pizza = factory.createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
}
//这里封装似乎只是把问题带到了SimplePizzaFactory中，还是需要不断的修改代码，封装只是可以带来复用，实际上封装是为了把不变的部分和变化的部分隔离开，也就是把实例化具体类的部分抽离出来，使他们不会干扰其他部分，对修改开放的问题暂时搁置
```

有许多不同地区的Pizza Store，可能它们的口味不相同

- 设计原则

```java
//面向接口编程

//Pizza对象的实例化是在工厂中完成的，给不同地区的store提供不同的factory，去产生不同的pizza
//其他的store去实现这一接口
public interface SimplePizzaFactory {
     Pizza createPizza(String type);
}

//产生new york风味的cheese比萨
NYPizzaFactory nyPizzaFactory = new NYPizzaFactory();
PizzaStore nyStore = new PizzaStore(nyPizzaFactory);
nyStore.orderPizza("cheese");

//产生chicago风味的cheese比萨
ChicagoPizzaFactory chicagoPizzaFactory = new ChicagoPizzaFactory();
PizzaStore chicagoStore = new PizzaStore(chicagoPizzaFactory);
chicagoStore.orderPizza("cheese");
```

不同的Pizza Store具体的加工方式不一样，例如烘烤、切片、包装不同，让store自己控制比萨的制作

```java
public abstract class PizzaStore {

    //orderPizza对pizza对象做了一系列工作但是没有并不知道具体的执行逻辑，
    public Pizza orderPizza(String type){
        Pizza pizza = createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
    //此方法就是一个工厂，在子类中处理对象的实例化
    abstract Pizza createPizza(String type);
}

public class ChicagoPizzaStore extends PizzaStore{

    @Override
    public Pizza createPizza(String type){
        Pizza pizza = null;
        if (type.equals("cheese")){
            pizza = new ChicagoCheesePizza();
        }else if (type.equals("greek")){
            pizza = new ChicagoGreekPizza();
        }
        return pizza;
    }
}

//所有的工厂模式都用来封装对象的创建，工厂方方法模式通过让子类决定该创建什么，来达到对象创建过程封装的目的，工厂模式有两部分组成，一部分是创建者，另一部分是产品类
```

![image-20220827105034050](D:\笔记\设计模式.assets\image-20220827105034050.png)

### 定义

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法把类的实现推迟到子类中

![image-20220827110011729](D:\笔记\设计模式.assets\image-20220827110011729.png)

抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

![image-20220827170343348](D:\笔记\设计模式.assets\image-20220827170343348.png)

## 5、单例模式

ChocolateBoiler控制巧克力熔炉的加热、填充、排出

```java
public class ChocolateBoiler {

    private boolean empty;
    private boolean boiled;

    public ChocolateBoiler(){
        empty = true;
        boiled = false;
    }

    public void fill(){
        if (!isEmpty()){
            empty = false;
            boiled = false;
        }
    }

    public void drain(){
        if (!isEmpty() && isBoiled()){
            empty = true;
        }
    }

    public void boil(){
        if (!isEmpty() && !isBoiled()){
            boiled = true;
        }
    }
}
```

如果系统中只有一个ChocolateBoiler实例那么工厂能正常运行，一旦初始化了多个实例那么就会造成问题，因为这些实例并没有共享熔炉当前的状态，所以造成控制紊乱。

### 改变

```java
//经典的单件模式
public class ChocolateBoiler {

    private boolean empty;
    private boolean boiled;
    private static ChocolateBoiler chocolateBoiler;

    private ChocolateBoiler(){
        empty = true;
        boiled = false;
        chocolateBoiler = null;
    }

    public static ChocolateBoiler getInstance(){
        if (chocolateBoiler == null){
            chocolateBoiler = new ChocolateBoiler();
        }
        return chocolateBoiler;
    }
    ……
}

ChocolateBoiler instance1 = ChocolateBoiler.getInstance();
ChocolateBoiler instance2 = ChocolateBoiler.getInstance();
System.out.println(instance1 == instance2);
// ==>true

//采用延迟实例化的方式创建单件，常用于对资源敏感的对象
//不支持多线程
for (int i =0;i<2;i++){
    new Thread(()->{
        ChocolateBoiler instance = ChocolateBoiler.getInstance();
        System.out.println(instance);
    }).start();
}
//==>chocolate._01.ChocolateBoiler@338f4e11
//   chocolate._01.ChocolateBoiler@445e853

//处理多线程，将getInstance变成同步，不会有多个线程进入getInstance方法，没有性能需求时使用
public static synchronized ChocolateBoiler getInstance(){
    ……
}

//同步会降低性能，实际上只需要第一次调用getInstance时保证是同步就行
//解决方法一：什么都不做，如果getInstance调用次数少，对程序不重要
//解决方法二：使用不采用延迟实例化的方式，也就是急切创建实例，这个实例一定会使用到时采用
public class ChocolateBoiler {

    private boolean empty;
    private boolean boiled;
    private static ChocolateBoiler chocolateBoiler  =new ChocolateBoiler();

    private ChocolateBoiler(){
        empty = true;
        boiled = false;
    }

    public static ChocolateBoiler getInstance(){
        return chocolateBoiler;
    }
}
//解决方法三：使用双重检测锁，检查实例是否创建，如果未创建才进行同步，这样只有第一次才会同步，有性能需求时使用
public class ChocolateBoiler {

    private boolean empty;
    private boolean boiled;
    //volatile保证被初始化成实例时，多个线程能正确的处理chocolateBoiler
    //保证变量再不同线程共享，禁止指令重排
    private static volatile ChocolateBoiler chocolateBoiler;

    private ChocolateBoiler(){
        empty = true;
        boiled = false;
        chocolateBoiler = null;
    }

    public static ChocolateBoiler getInstance(){
        //实例不存在进入同步区，只有第一次才会进入同步区
        //第一次判断是为了完成实例化后，之后的线程不再执行同步代码块
        if (chocolateBoiler == null){
            synchronized (ChocolateBoiler.class){
                //第二次判断是为了防止对此实例化，一个线程实例化后就会释放锁
                //其他线程就会进入同步代码块，加上判断就不需要多次实例化
                if (chocolateBoiler == null){
                    chocolateBoiler = new ChocolateBoiler();
                }
            }

        }
        return chocolateBoiler;
    }
}
```

### 定义

单件模式确保一个类只有一个实例，并提供一个全局访问点、

## 6、命令模式

```java
public class Light {

    public void on(){
        System.out.println("开灯");
    }

    public void off(){
        System.out.println("关灯");
    }
}

public interface Command {

    void execute();
}

//命令对象将接收者和动作包进对象中，这个对象只暴露出一个execute方法，当被调用时接收者执行动作
public class LightOnCommand implements Command{

    private Light light;

    public LightOnCommand(Light light){
        this.light = light;
    }


    @Override
    public void execute() {
        light.on();
    }
}

public class SimpleRemoteControl {

    private Command slot;

    public void setCommand(Command command){
        slot = command;
    }

    public void buttonWasPressed(){
        slot.execute();
    }

}

SimpleRemoteControl remoteControl = new SimpleRemoteControl();
Light light = new Light();
LightOnCommand lightOnCommand = new LightOnCommand(light);
remoteControl.setCommand(lightOnCommand);
remoteControl.buttonWasPressed();

//完整遥控器
public class RemoteControl {

    private Command[] onCommands;
    private Command[] offCommands;

    public RemoteControl() {
        onCommands = new Command[7];
        offCommands = new Command[7];

        NoCommand noCommand = new NoCommand();
        for (int i = 0; i < 7; i++) {
            onCommands[i] = noCommand;
            offCommands[i] = noCommand;
        }
    }
    public void setCommand(int slot, Command onCommand, Command offCommand){
        onCommands[slot] = onCommand;
        offCommands[slot] = offCommand;
    }

    public void onButtonWasPushed(int slot){
        onCommands[slot].execute();
    }

    public void offButtonWasPushed(int slot){
        offCommands[slot].execute();
    }
}
```

### 定义

命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

![image-20220830132604922](D:\笔记\设计模式.assets\image-20220830132604922.png)

### 改变

添加撤销功能

```java

```











