# 一、设计模式的七大原则

## 单一职责

对某个类A来说，它应该只负责一项职责。如果该类有两个职责R1和R2，当R1需要需求变更时，修改A可能对R2造成影响，所以需要进一步将A的粒度分解为A1，A2分别负责R1，R2。

## 接口分离原则

使用方不应该依赖于它不使用的方法，ClientA可能只需要调用A方法，B、C方法对A来说显然是多余的，使用一个通用接口造成接口臃肿。

![image-20220711085049747](设计模式.assets\image-20220711085049747.png)

采用接口分离原则后，每一个客户类有自己独立的接口，该接口中只声明与自己相关的方法

![image-20220711085534276](设计模式.assets\image-20220711085534276.png)

## 依赖倒置原则

系统需要连接自己所使用的数据库

```java
public class Demo01 {
    public static void main(String[] args) {
        DataBase dataBase = new DataBase();
        dataBase.connect(new MySQL());
    }
}

class MySQL{
    public void connect(){
        System.out.println("连接MySQL数据库");
    }
}

class DataBase{
    public void connect(MySQL mysql){
        mysql.connect();
    }
}

```

这种情况下DataBase是直接依赖于MySQL的，当使用的数据库是SQLServer时，需要在DataBase中添加对应SQLServer的连接方法，以此类推，每新增一个数据库就要在DataBase中添加对应的连接方法

```java
public class Demo01 {
    public static void main(String[] args) {
        DataBase dataBase = new DataBase();
//        dataBase.connectMySQL(new MySQL());
        dataBase.connectSQLServer(new SQLServer());
    }
}

class MySQL{
    public void connect(){
        System.out.println("连接MySQL数据库");
    }
}
class SQLServer{
    public void connect(){
        System.out.println("连接SQLServer数据库");
    }
}

class DataBase{
    public void connectMySQL(MySQL mysql){
        mysql.connect();
    }
    public void connectSQLServer(SQLServer sqlServer){
        sqlServer.connect();
    }
}
```

在两者之间加一层抽象层（采用依赖反转），DataBase依赖于DBMS接口，MySQL、SQLServer等都需要实现（依赖）DMBS接口

```java
public class Demo01 {
    public static void main(String[] args) {
        DataBase dataBase = new DataBase();
        dataBase.connect(new MySQL());
    }
}

interface DBMS{
    public void connect();
}

class MySQL implements DBMS{
    public void connect(){
        System.out.println("连接MySQL数据库");
    }
}
class SQLServer implements DBMS{
    public void connect(){
        System.out.println("连接SQLServer数据库");
    }
}

class DataBase{
    public void connect(DBMS dbms){
        dbms.connect();
    }
}
```

依赖反转的核心思想是面向接口编程，高层模块（调用者）不依赖于底层模块（被调用者），而是通过抽象来相互依赖。抽象制定好规范，具体的实现细节依赖于抽象。

依赖传递主要有接口传递、构造函数传递、set方法传递

## 里氏替换原则

用一个子类对象替换基类对象，程序将不会产生任何错误和异常。也就是说尽量不去重写父类的方法，子类可以扩展父类的功能，但不能改变父类原有的功能。

```jsx
public class Demo {
    public static void main(String[] args) {
        Line line = new Line();
        line.isOn();
        //将父类对象替换成子类对象发生发生了错误
        LineSegment lineSegment = new LineSegment();
        lineSegment.isOn();
    }
}


class Line{
    
    public void isOn(){
        System.out.println("判断一个点是否在一条直线上");
    }
}

class LineSegment extends Line{

    //显然判断一个点是否在一条线段上还需要考虑两端的界限，所以重写isOn方法
    public void isOn(){
        System.out.println("判断一个点是否在一条线段上");
    }
}
```

使用一个BaseLine作为基类，提取共同的方法

```java
class BaseLine{
    public void getSlope(){
        System.out.println("得到斜率");
    }

}

class Line extends BaseLine{

    public void isOn(){
        System.out.println("判断一个点是否在一条直线上");
    }
}

class LineSegment extends BaseLine{

    //显然判断一个点是否在一条线段上还需要考虑两端的界限
    public void isOn(){
        System.out.println("判断一个点是否在一条线段上");
    }
}
```

如果违反里氏替换原则，要将两者之间的关系重新定义，找到更高层次的抽象。改变原有的继承关系，使用依赖、聚合、组合的关系。

## 开闭原则

一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。就像你可以穿各种各样的衣服而身体却不用改变（如果衣服穿不上那一定是衣服太小了，换一件衣服就行了）

假如你是一家手机店的老板，你售卖小米和苹果两种手机，你每天都能卖出一部手机（你问我是什么手机？当然希望是苹果，因为利润高），现在你听说华为手机销量高，你的脑海中已经浮现了每天能卖5部手机的场景，三年后你将迎娶白富美走上人生巅峰。

```java
public class Demo {
    public static void main(String[] args) {
        Store store = new Store();
        store.sell(new XIAOMI());
    }
}

class MobilePhone {
    public final int code;
    MobilePhone(int code){
        this.code=code;
    }

}

class XIAOMI extends MobilePhone {
    XIAOMI(){
        super(1);
    }
}

class APPLE extends MobilePhone {
    APPLE(){
        super(2);
    }
}

class Store {

    public void sell(MobilePhone phone) {
        switch (phone.code) {
            case 1:
                System.out.println("卖出了一台小米手机");
                break;
            case 2:
                System.out.println("卖出了一台苹果手机");
                break;
            default:
                System.out.println("卖出失败");
        }
    }
}
```

说干就干，你连夜从华强北进一批华为13ProMax（当然是卖的最火热的远峰蓝），刚摆上柜台你已经把未来女儿的名字都想好了。一晃就是一天，聪明的你发现今天居然一个来买华为13的顾客都没有，于是连晚饭都吃不下去。正当你一筹莫展的时候你想到了远房表舅家的二儿子学的是市场营销管理。此处省略5w字，原来是商店没有重新打广告的原因，没有人知道你卖华为手机（你问每天不是有一个顾客吗？我的评价是 买小米、苹果的人会买华为吗？）

```jsx
class HUAWEI extends MobilePhone{
    HUAWEI(){
        super(3);
    }
}
```

于是，做了广告。编不下去了，直接上代码

```jsx
class Store {

    public void sell(MobilePhone phone) {
        switch (phone.code) {
            case 1:
                System.out.println("卖出了一台小米手机");
                break;
            case 2:
                System.out.println("卖出了一台苹果手机");
                break;
            case 3:
                System.out.println("卖出了一台华为手机");
                break;
            default:
                System.out.println("卖出失败");
        }
    }
}
```

今天你格外高兴，因为你不仅卖出了一台苹果手机还卖出了两台华为手机，但聪明的你并不满足于此。你想扩大手机种类，可一想到又要针对特定的手机做广告，你又沉默了。过了两分钟你想到了一个绝佳的方案，你打算把商店改名叫全能王手机店，这样所有手机都能卖。（若干年后，遭遇金融危机的你一无所有……）

```jsx
public class Demo {
    public static void main(String[] args) {
        Store store = new Store();
        store.sell(new XIAOMI());
        store.sell(new HUAWEI());
    }
}

abstract class MobilePhone {
    public final int code;
    MobilePhone(int code){
        this.code=code;
    }

    abstract public void sell();
}

class XIAOMI extends MobilePhone {
    XIAOMI(){
        super(1);
    }

    @Override
    public void sell() {
        System.out.println("卖出了一台小米手机");
    }
}

class APPLE extends MobilePhone {
    APPLE(){
        super(2);
    }
    @Override
    public void sell() {
        System.out.println("卖出了一台苹果手机");
    }
}
class HUAWEI extends MobilePhone{
    HUAWEI(){
        super(3);
    }
    @Override
    public void sell() {
        System.out.println("卖出了一台华为手机");
    }
}

class Store {
    public void sell(MobilePhone phone) {
        phone.sell();
    }
}
```

## 迪米特原则

迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息。迪米特法则还有个更简单的定义:只与直接的朋友通信。每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

一个人阅读一本小说首先要打开手机，进入APP，选择对应的小说

```jsx
public class Demo{
    public static void main(String[] args) {
        Person person = new Person();
        person.read();
    }
}

class Person {

    public void read() {
        MobilePhone mobilePhone = new MobilePhone("IPhone 13");
        System.out.println("打开了"+mobilePhone.getName());
        Application app = new Application("笔趣阁");
        mobilePhone.enterApp(app);
        Book book = new Book("斗破苍穹");
        app.selectBook(book);
    }
}


class MobilePhone {

    private String name;

    MobilePhone(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
    public void enterApp(Application application) {
        System.out.println("进入了"+name;
    }

}

class Application {
    private String name;

    Application(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void selectBook(Book book) {
        System.out.println("正在阅读" + name);
    }
}

class Book {
    private String name;

    Book(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

Person没有和直接的朋友通信，手机类、应用类、书籍类都是以局部变量的形式出现在Person内部

```jsx
package lkp;

public class Demo {
    public static void main(String[] args) {
        Person person = new Person();
        MobilePhone mobilePhone = new MobilePhone("IPhone 13");
        Application application = new Application("笔趣阁");
        Book book = new Book("斗破苍穹");
        application.setBook(book);
        mobilePhone.setApp(application);
        person.setMobilePhone(mobilePhone);
        person.read();
    }
}

// 人只操作手机
class Person {
    private MobilePhone mobilePhone;

    public void setMobilePhone(MobilePhone mobilePhone) {
        this.mobilePhone = mobilePhone;
    }

    public void read() {
        System.out.println("打开了" + this.mobilePhone.getName());
        mobilePhone.enterApp();
    }
}

//手机操作app
class MobilePhone {

    private Application app;
    private String name;

    MobilePhone(String name) {
        this.name = name;
    }

    public void setApp(Application app) {
        this.app = app;
    }


    public String getName() {
        return name;
    }

    public void enterApp() {
        System.out.println("进入了" + app.getName());
        app.selectBook();
    }

}
//app操作内部书籍
class Application {
    private String name;
    public Book book;

    Application(String name) {
        this.name = name;
    }

    public void setBook(Book book) {
        this.book = book;
    }

    public String getName() {
        return name;
    }

    public void selectBook() {
        System.out.println("正在阅读" + book.getName());
    }
}

class Book {
    private String name;

    Book(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
}
```

## 合成与复用原则

尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

# 二、设计模式

> 软件开发中不变的真理     CHANGE

## 1、策略模式

```java
public abstract class Duck {

    public void quack(){
        System.out.println("呱呱叫");
    }
    
    abstract public void display();
}


public class MallardDuck extends Duck{

    @Override
    public void display() {
        System.out.println("绿头鸭子");
    }
}

public class RedheadDuck extends Duck{
    
    @Override
    public void display() {
        System.out.println("红头鸭子");
    }
}

public class RubberDuck extends Duck{

    @Override
    public void quack(){
        System.out.println("吱吱吱");
    }
    
    @Override
    public void display() {
        System.out.println("橡皮鸭子");
    }
}
```

### 改变

给鸭子增加一个飞的方法

- 继承

```java
//给鸭子增加一个fly方法，在父类中添加一个新方法，这样鸭子就能获取“飞”的行为
public abstract class Duck {

    ……
    public void fly(){
        System.out.println("飞");
    }
}

//使用继承来提供fly行为，改变会牵一发而动全身，造成其他不想要的改变
//橡皮鸭子没有飞的能力，为了复用而使用继承会带来一些问题
Duck rubberDuck = new RubberDuck();
rubberDuck.fly();

//可以通过重写来暂时解决这一问题，当不需要的改变很多时，可能要造成大量的“什么都不做”重写
public class RubberDuck extends Duck{
    ……
    @Override
    public void fly() {
        //什么都不做
    }
}
```

- 接口

```java
//使用接口，把一些特殊的行为（fly）提取出来放到接口中，有需要的鸭子自己去实现
public interface IFly {

    void fly();
}

public class MallardDuck extends Duck implements IFly {
    ……
    @Override
    public void fly() {
        System.out.println("绿头鸭子飞");
    }
}

public class RedheadDuck extends Duck implements IFly {
    ……
    @Override
    public void fly() {
        System.out.println("红头鸭子飞");
    }
}

//接口解决了继承带来的牵一发而动全身的问题，但带来无法复用的问题，每当需要飞的行为不得不实现接口，造成冗余
```

- 设计原则

```java
//开闭原则，对扩展开放，对修改关闭，找出应用中可能需要的变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。把会变化的部分取出封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。
//依赖倒置，针对接口编程而不是针对实现编程，RedheadDuck和MallardDuck是直接实现IFly接口，被实现所绑定

//在IFly的基础上加一层行为层，这层实现具体的fly行为，不再由XXXDuck直接实现fly行为，这样Duck就可以通过IFly指定规则，不去关心具体实现，面向接口编程
public class FlyWithWings implements IFly{
    @Override
    public void fly() {
        System.out.println("用翅膀飞");
    }
}

public class FlyNoWay implements IFly{
    @Override
    public void fly() {
         //不能飞
        System.out.println("不能飞");
    }
}

//多用组合少用继承
//利用运行时多态，用IFly表示fly行为，在运行时引用正确的行为
public abstract class Duck {

    IFly iFly;
    ……
    public void fly(){
        iFly.fly();
    }
}

public class RedheadDuck extends Duck {

    public RedheadDuck(){
        iFly = new FlyWithWings();
    }
    ……
}

public class MallardDuck extends Duck {

    public MallardDuck() {
        iFly = new FlyWithWings();
    }
    ……
}

public class RubberDuck extends Duck {

    public RubberDuck() {
        iFly = new FlyNoWay();
    }
    ……
}
//定义了了算法族（IFly），封装了具体fly行为，让FlyWithWings和FlyNoWay可以相互替换，使用FlyWithWings和FlyNoWay的部分不用关心算法的变化
```

### 定义

策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

## 2、观察者模式

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新

```java
//设计原则----针对接口编程
//主题
public interface Subject {

    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}
//观察者
public interface Observer {

    void update(float temp,float humidity,float pressure);
}
//展示面板
public interface DisplayElement {

    void display();
}

//
public class WeatherData implements Subject {

    //设计原则----多用组合，少用继承
    private ArrayList<Observer> observers;
    private float temp;
    private float humidity;
    private float pressure;

    public WeatherData() {
        observers = new ArrayList<Observer>();
    }

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(temp, humidity, pressure);
        }
    }

    public void measurementsChanged() {
        notifyObservers();
    }

    public void setMeasurements(float temp, float humidity, float pressure) {
        this.temp = temp;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }
}


public class CurrentConditionsDisplay implements Observer,DisplayElement{

    private float temp;
    private float humidity;
//    private Subject weatherData;

    public CurrentConditionsDisplay(WeatherData weatherData){
//        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }

    @Override
    public void display() {
        System.out.println("CurrentConditionsDisplay:"+"temp="+ temp+"  humidity"+humidity);
    }

    @Override
    public void update(float temp, float humidity, float pressure) {
        this.temp=temp;
        this.humidity=humidity;
        display();
    }
}

//主题注册观察者，有信息更新时推送给观察者
public class Demo {
    public static void main(String[] args) {

        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
        weatherData.setMeasurements(50,20,45);
    }
}
//为了交互对象之间的松耦合设计而努力
//设计原则----对扩展开放，对修改关闭，当需要添加新的展示面板不用修改主题，只需注册并自定义展示效果
```

### Java内置的观察者模式

```java
//subject
//与自定义的主题不同的是多了changed属性，changed必须为true，才能通知观察者更新状态，用于过滤一些细微的改变，当这些改变微小时不需要通知观察者做出更新
//
//protected synchronized void setChanged() {
      // if (改变超过一定范围)
     //    changed = true;
//}
public class WeatherData extends Observable {

    private float temp;
    private float humidity;
    private float pressure;

    public float getTemp() {
        return temp;
    }

    public float getHumidity() {
        return humidity;
    }

    public float getPressure() {
        return pressure;
    }

    public void measurementsChanged() {
        setChanged();
        notifyObservers();
    }

    public void setMeasurements(float temp, float humidity, float pressure) {
        this.temp = temp;
        this.humidity = humidity;
        this.pressure = pressure;
        measurementsChanged();
    }
}

//observer
//和自己实现的接口不同，观察者获取数据是通过“拉的方式”，自己想要什么数据从subject中get,而不是subject直接推
package weather._01;

import java.util.Observable;
import java.util.Observer;

public class CurrentConditionsDisplay implements Observer, DisplayElement{

    private float temp;
    private float humidity;

    public CurrentConditionsDisplay(WeatherData weatherData){
        weatherData.addObserver(this);
    }

    @Override
    public void display() {
        System.out.println("CurrentConditionsDisplay:"+"temp="+ temp+"  humidity"+humidity);
    }

    @Override
    public void update(Observable o, Object arg) {
        WeatherData weatherData = (WeatherData) o;
        this.temp = weatherData.getTemp();
        this.humidity = weatherData.getHumidity();
        display();
    }
}

//java.util.Observable的缺点
//是一个类，java不支持多继承，限制了使用场景
//更新操作中含有protect访问限制，只能继承使用，不能组合
```

## 3、装饰器模式

```java
//饮料基类
public class Beverage {

    private String description;
    private boolean milk;
    private boolean soy;
    private boolean mocha;
    private boolean whip;

    //setter和getter
    //计算配料价格
    public double cost(){

        double cost= 0;
        if (isMilk()){
            cost +=Constant.MILK_COST;
        }
        if (isSoy()){
            cost +=Constant.SOY_COST;
        }if (isMocha()){
            cost +=Constant.MOCHA_COST;
        }if (isWhip()){
            cost +=Constant.WHIP_COST;
        }
        return cost;
    }

    public String getAddString() {
        String add=" add";
        if (isMilk()){
            add +=" milk";
        }if (isMocha()){
            add +=" mocha";
        }if (isSoy()){
            add +=" soy";
        }if (isWhip()){
            add +=" whip";
        }
        return add;
    }
}

//
public class DarkRoast extends Beverage{

    public DarkRoast(){
        setDescription("Dark Roast");
    }

    @Override
    public double cost() {
        return super.cost()+Constant.DARK_ROAST_COST;
    }

    @Override
    public String toString() {
        return getDescription() +getAddString()+" is $"+ cost();
    }
}

DarkRoast darkRoast = new DarkRoast();
darkRoast.setMilk(true);
darkRoast.setMocha(true);
System.out.println(darkRoast);
//==> Dark Roast add milk mocha is $6.5
```

### 改变

出现新的配料，就需要修改大量的代码，对于冰红茶不需要豆浆等配料，要加双倍的奶泡也无法实现

```java
//以饮料为主体，将各种配料当成装饰品

//无论是具体饮料还是配料都是Beverage的子类
public abstract class Beverage {
    private String description;

    public void setDescription(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    public abstract double cost();
}

//具体饮料
public class HouseBlend extends Beverage{

    public HouseBlend(){
        setDescription("House Blend");
    }

    @Override
    public double cost() {
        return Constant.HOUSE_BLEND_COST;
    }
}

//装饰器和主体拥有相同的类型，
public abstract class CondimentDecorator extends Beverage{

    public abstract String getDescription();
}

//装饰者
public class Mocha extends CondimentDecorator{

    //是主体也是被装饰者
    private Beverage beverage;

    public Mocha(Beverage beverage){
        this.beverage=beverage;
    }

    @Override
    public double cost() {
        return beverage.cost()+ Constant.MOCHA_COST;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription()+" + Mocha";
    }
}

Beverage houseBlend = new HouseBlend();
houseBlend = new Mocha(houseBlend);
houseBlend = new Mocha(houseBlend);
System.out.println(houseBlend.getDescription());
System.out.println(houseBlend.cost());
// ==> House Blend + Mocha + Mocha  5.0

//装饰者和被装饰者有相同的超类型，使得装饰者可以替代被装饰者（被装饰者以实例变量的形式组合到装饰者中），并添加装饰者自己的行为。
```

![image-20220823105804551](D:\笔记\设计模式.assets\image-20220823105804551.png)

### 定义

装饰者模式动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

![image-20220823103459491](D:\笔记\设计模式.assets\image-20220823103459491.png)

## 4、工厂模式

```java
public interface Pizza {
    void prepare();
    void bake();
    void cut();
    void box();
}

public Pizza orderPizza(String type){
    //容易变化的部分
    Pizza pizza = null;
    if (type.equals("cheese")){
       pizza = new CheesePizza();
    }else if (type.equals("greek")){
        pizza = new GreekPizza();
    }
    //不会轻易改变的部分
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
}
```

### 改变

添加新的的比萨种类，删除一些旧的种类

- 直接修改

```java
//这部分会不断修改代码
public Pizza orderPizza(String type){
    //容易变化的部分
    Pizza pizza = null;
    if (type.equals("cheese")){
       pizza = new CheesePizza();
    }else if (type.equals("clam")){
        pizza = new ClamPizza();
    }
    ……
}
```

- 设计原则


```java
//封装变化
//工厂处理创建对象的细节，SimplePizzaFactory对象就叫做工厂
public class SimplePizzaFactory {
    public Pizza createPizza(String type){
        Pizza pizza = null;
        if (type.equals("cheese")){
            pizza = new CheesePizza();
        }else if (type.equals("greek")){
            pizza = new GreekPizza();
        }
        return pizza;
    }
}

public class PizzaStore {
    private SimplePizzaFactory factory;
    public PizzaStore(SimplePizzaFactory factory){
        this.factory=factory;
    }

    public Pizza orderPizza(String type){
        Pizza pizza = factory.createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
}
//这里封装似乎只是把问题带到了SimplePizzaFactory中，还是需要不断的修改代码，封装只是可以带来复用，实际上封装是为了把不变的部分和变化的部分隔离开，也就是把实例化具体类的部分抽离出来，使他们不会干扰其他部分，对修改开放的问题暂时搁置
```

有许多不同地区的Pizza Store，可能它们的口味不相同

- 设计原则

```java
//面向接口编程

//Pizza对象的实例化是在工厂中完成的，给不同地区的store提供不同的factory，去产生不同的pizza
//其他的store去实现这一接口
public interface SimplePizzaFactory {
     Pizza createPizza(String type);
}

//产生new york风味的cheese比萨
NYPizzaFactory nyPizzaFactory = new NYPizzaFactory();
PizzaStore nyStore = new PizzaStore(nyPizzaFactory);
nyStore.orderPizza("cheese");

//产生chicago风味的cheese比萨
ChicagoPizzaFactory chicagoPizzaFactory = new ChicagoPizzaFactory();
PizzaStore chicagoStore = new PizzaStore(chicagoPizzaFactory);
chicagoStore.orderPizza("cheese");
```

不同的Pizza Store具体的加工方式不一样，例如烘烤、切片、包装不同，让store自己控制比萨的制作

```java
public abstract class PizzaStore {

    //orderPizza对pizza对象做了一系列工作但是没有并不知道具体的执行逻辑，
    public Pizza orderPizza(String type){
        Pizza pizza = createPizza(type);
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
    //此方法就是一个工厂，在子类中处理对象的实例化
    abstract Pizza createPizza(String type);
}

public class ChicagoPizzaStore extends PizzaStore{

    @Override
    public Pizza createPizza(String type){
        Pizza pizza = null;
        if (type.equals("cheese")){
            pizza = new ChicagoCheesePizza();
        }else if (type.equals("greek")){
            pizza = new ChicagoGreekPizza();
        }
        return pizza;
    }
}

//所有的工厂模式都用来封装对象的创建，工厂方方法模式通过让子类决定该创建什么，来达到对象创建过程封装的目的，工厂模式有两部分组成，一部分是创建者，另一部分是产品类
```

![image-20220827105034050](D:\笔记\设计模式.assets\image-20220827105034050.png)

### 定义

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法把类的实现推迟到子类中

![image-20220827110011729](D:\笔记\设计模式.assets\image-20220827110011729.png)

抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

![image-20220827170343348](D:\笔记\设计模式.assets\image-20220827170343348.png)

## 5、单例模式

ChocolateBoiler控制巧克力熔炉的加热、填充、排出

```java
public class ChocolateBoiler {

    private boolean empty;
    private boolean boiled;

    public ChocolateBoiler(){
        empty = true;
        boiled = false;
    }

    public void fill(){
        if (!isEmpty()){
            empty = false;
            boiled = false;
        }
    }

    public void drain(){
        if (!isEmpty() && isBoiled()){
            empty = true;
        }
    }

    public void boil(){
        if (!isEmpty() && !isBoiled()){
            boiled = true;
        }
    }
}
```

如果系统中只有一个ChocolateBoiler实例那么工厂能正常运行，一旦初始化了多个实例那么就会造成问题，因为这些实例并没有共享熔炉当前的状态，所以造成控制紊乱。

### 改变

```java
//经典的单件模式
public class ChocolateBoiler {

    private boolean empty;
    private boolean boiled;
    private static ChocolateBoiler chocolateBoiler;

    private ChocolateBoiler(){
        empty = true;
        boiled = false;
        chocolateBoiler = null;
    }

    public static ChocolateBoiler getInstance(){
        if (chocolateBoiler == null){
            chocolateBoiler = new ChocolateBoiler();
        }
        return chocolateBoiler;
    }
    ……
}

ChocolateBoiler instance1 = ChocolateBoiler.getInstance();
ChocolateBoiler instance2 = ChocolateBoiler.getInstance();
System.out.println(instance1 == instance2);
// ==>true

//采用延迟实例化的方式创建单件，常用于对资源敏感的对象
//不支持多线程
for (int i =0;i<2;i++){
    new Thread(()->{
        ChocolateBoiler instance = ChocolateBoiler.getInstance();
        System.out.println(instance);
    }).start();
}
//==>chocolate._01.ChocolateBoiler@338f4e11
//   chocolate._01.ChocolateBoiler@445e853

//处理多线程，将getInstance变成同步，不会有多个线程进入getInstance方法，没有性能需求时使用
public static synchronized ChocolateBoiler getInstance(){
    ……
}

//同步会降低性能，实际上只需要第一次调用getInstance时保证是同步就行
//解决方法一：什么都不做，如果getInstance调用次数少，对程序不重要
//解决方法二：使用不采用延迟实例化的方式，也就是急切创建实例，这个实例一定会使用到时采用
public class ChocolateBoiler {

    private boolean empty;
    private boolean boiled;
    private static ChocolateBoiler chocolateBoiler  =new ChocolateBoiler();

    private ChocolateBoiler(){
        empty = true;
        boiled = false;
    }

    public static ChocolateBoiler getInstance(){
        return chocolateBoiler;
    }
}
//解决方法三：使用双重检测锁，检查实例是否创建，如果未创建才进行同步，这样只有第一次才会同步，有性能需求时使用
public class ChocolateBoiler {

    private boolean empty;
    private boolean boiled;
    //volatile保证被初始化成实例时，多个线程能正确的处理chocolateBoiler
    //保证变量再不同线程共享，禁止指令重排
    private static volatile ChocolateBoiler chocolateBoiler;

    private ChocolateBoiler(){
        empty = true;
        boiled = false;
        chocolateBoiler = null;
    }

    public static ChocolateBoiler getInstance(){
        //实例不存在进入同步区，只有第一次才会进入同步区
        //第一次判断是为了完成实例化后，之后的线程不再执行同步代码块
        if (chocolateBoiler == null){
            synchronized (ChocolateBoiler.class){
                //第二次判断是为了防止对此实例化，一个线程实例化后就会释放锁
                //其他线程就会进入同步代码块，加上判断就不需要多次实例化
                if (chocolateBoiler == null){
                    chocolateBoiler = new ChocolateBoiler();
                }
            }

        }
        return chocolateBoiler;
    }
}
```

### 定义

单件模式确保一个类只有一个实例，并提供一个全局访问点、

## 6、命令模式

```java
public class Light {

    public void on(){
        System.out.println("开灯");
    }

    public void off(){
        System.out.println("关灯");
    }
}

public interface Command {

    void execute();
}

//命令对象将接收者和动作包进对象中，这个对象只暴露出一个execute方法，当被调用时接收者执行动作
public class LightOnCommand implements Command{

    private Light light;

    public LightOnCommand(Light light){
        this.light = light;
    }


    @Override
    public void execute() {
        light.on();
    }
}

public class SimpleRemoteControl {

    private Command slot;

    public void setCommand(Command command){
        slot = command;
    }

    public void buttonWasPressed(){
        slot.execute();
    }

}

SimpleRemoteControl remoteControl = new SimpleRemoteControl();
Light light = new Light();
LightOnCommand lightOnCommand = new LightOnCommand(light);
remoteControl.setCommand(lightOnCommand);
remoteControl.buttonWasPressed();

//完整遥控器
public class RemoteControl {

    private Command[] onCommands;
    private Command[] offCommands;

    public RemoteControl() {
        onCommands = new Command[7];
        offCommands = new Command[7];

        NoCommand noCommand = new NoCommand();
        for (int i = 0; i < 7; i++) {
            onCommands[i] = noCommand;
            offCommands[i] = noCommand;
        }
    }
    public void setCommand(int slot, Command onCommand, Command offCommand){
        onCommands[slot] = onCommand;
        offCommands[slot] = offCommand;
    }

    public void onButtonWasPushed(int slot){
        onCommands[slot].execute();
    }

    public void offButtonWasPushed(int slot){
        offCommands[slot].execute();
    }
}
```

### 定义

命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

![image-20220830132604922](D:\笔记\设计模式.assets\image-20220830132604922.png)

### 改变

添加撤销功能

```java

```











